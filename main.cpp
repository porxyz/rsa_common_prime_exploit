#include <iostream>
#include <filesystem>
#include <map>
#include <string>
#include <cstdio>

#include <openssl/pem.h>
#include <openssl/evp.h>
#include <openssl/rsa.h>
#include <openssl/bn.h>
#include <openssl/err.h>


typedef struct
{
    BIGNUM *n;
    BIGNUM *e;
} RSA_Public_Key;

typedef struct
{
    BIGNUM *n;
    BIGNUM *e;
    BIGNUM *d;

    BIGNUM *p;
    BIGNUM *q;

    BIGNUM *dmp1; // d mod (p-1)
    BIGNUM *dmq1; // d mod (q-1)
    BIGNUM *iqmp; // (inverse of q) mod p
} RSA_Private_Key;

//print a big number
static inline void print_bignum(BIGNUM* b)
{
    char* ascii = BN_bn2hex(b);
    if(!ascii)
    {
        std::cerr << "BN_bn2hex() failed" << std::endl;
        exit(-1);
    }

    std::cout << ascii;

    OPENSSL_free(ascii);
}

//read the public RSA key from a pem encoded file
void ReadPublicKey(const char* path, const char* keyname, std::map<std::string, RSA_Public_Key> *keys)
{
    FILE *fp = fopen (path, "r");
    if (fp == NULL)
    {
        std::cerr << "fopen() failed!" << std::endl;
        return;
    }

    X509 *cert = NULL;
    EVP_PKEY *pkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL);

    if (pkey == NULL) 
    {
        rewind(fp);

        //maybe the file is a certificate
        cert = PEM_read_X509(fp, NULL, NULL, NULL);
        if(!cert) // we can do nothing at this point
        {
            fclose (fp);
            return;
        }

        pkey = X509_get0_pubkey(cert);
        if(!pkey)
        {
            fclose (fp);
            X509_free(cert);
            return;
        }
    }

    fclose(fp);

    RSA *rsa_key = EVP_PKEY_get1_RSA(pkey);
    if (!rsa_key)
    {
        std::cerr << "The key is not an RSA key!" << std::endl;

        if (cert)
        {
            X509_free(cert);
        }
        else
        {
            EVP_PKEY_free(pkey);
        }

        return;
    }

    const BIGNUM *n = RSA_get0_n(rsa_key);
    const BIGNUM *e = RSA_get0_e(rsa_key);

    if (n == NULL or e == NULL)
    {
        std::cerr << "RSA_get0_() failed" << std::endl;

        if (cert)
        {
            X509_free(cert);
        }
        else
        {
            EVP_PKEY_free(pkey);
        }

        RSA_free(rsa_key);

        return;
    }

    RSA_Public_Key rsa_pubkey;
    rsa_pubkey.n = BN_dup(n);
    if(rsa_pubkey.n == NULL)
    {
        std::cerr << "BN_dup(n) failed." << std::endl;
        exit(-1);
    }

    rsa_pubkey.e = BN_dup(e);
    if(rsa_pubkey.n == NULL)
    {
        std::cerr << "BN_dup(e) failed." << std::endl;
        exit(-1);
    }

    if(cert)
    {
        X509_free(cert);
    }
    else
    {
        EVP_PKEY_free(pkey);
    }

    RSA_free(rsa_key);

    keys[0][keyname] = rsa_pubkey;
}

void compute_private_key_with_known_prime(const RSA_Public_Key *public_key, RSA_Private_Key *private_key, const BIGNUM *prime, BN_CTX *bn_ctx)
{
    private_key->n = BN_dup(public_key->n);
    private_key->e = BN_dup(public_key->e);
    private_key->d = BN_new();

    private_key->p = BN_new();
    private_key->q = BN_new();

    private_key->dmp1 = BN_new();
    private_key->dmq1 = BN_new();
    private_key->iqmp = BN_new();

    BIGNUM *p_1 = BN_new();
    BIGNUM *q_1 = BN_new();
    BIGNUM *phi = BN_new();

    if (!private_key->n or !private_key->e or !private_key->d or !private_key->q or !private_key->p or !private_key->dmp1 or 
        !private_key->dmq1 or !private_key->iqmp or !p_1 or !q_1 or !phi)
    {
        std::cerr << "Unable to allocate memory for RSA private key numbers" << std::endl;
        exit(-1);
    }

    //compute p and q
    if (!BN_div(private_key->p, NULL, public_key->n, prime, bn_ctx) or !BN_div(private_key->q, NULL, public_key->n, private_key->p, bn_ctx))
    {
        std::cerr << "BN_div() failed" << std::endl;
        exit(-1);
    }

    // compute p-1 and q-1
    if (!BN_sub(p_1, private_key->p, BN_value_one()) or !BN_sub(q_1, private_key->q, BN_value_one()))
    {
        std::cerr << "BN_sub() failed" << std::endl;
        exit(-1);
    }

    //compute phi(n)
    if (!BN_mul(phi, p_1, q_1, bn_ctx))
    {
        std::cerr << "BN_mul() failed" << std::endl;
        exit(-1);
    }

    //compute the private exponent
    if (!BN_mod_inverse(private_key->d, private_key->e, phi, bn_ctx))
    {
        std::cerr << "BN_mod_inverse() failed" << std::endl;
        exit(-1);
    }

    //compute d mod (p-1) and d mod (q-1)
    if (!BN_mod(private_key->dmp1, private_key->d, p_1, bn_ctx) or !BN_mod(private_key->dmq1, private_key->d, q_1, bn_ctx))
    {
        std::cerr << "BN_mod_inverse() failed" << std::endl;
        exit(-1);
    }

    //compute (inverse of q) mod p
    if (!BN_mod_inverse(private_key->iqmp, private_key->q, private_key->p, bn_ctx))
    {
        std::cerr << "BN_mod_inverse() failed" << std::endl;
        exit(-1);
    }

    BN_free(p_1);
    BN_free(q_1);
    BN_free(phi);
}

/* print the public modulus */
void search_for_prime_collision(const std::map<std::string, RSA_Public_Key> *public_keys, std::map<std::string, RSA_Private_Key> *private_keys)
{
    //used for internal temp variables
    BN_CTX *bn_ctx = BN_CTX_new();
    if(!bn_ctx)
    {
        std::cerr << "BN_CTX_new() failed" << std::endl;
        exit(-1);
    }

    BIGNUM *r = BN_new();
    if(!r)
    {
        std::cerr << "BN_new() failed" << std::endl;
        exit(-1);
    }

    for (auto i = public_keys->begin(); i != public_keys->end(); i++)
    {
        for (auto j = public_keys->begin(); j != public_keys->end(); j++)
        {
             if(i == j)
            {
                continue;
            }

            if(BN_gcd(r, i->second.n, j->second.n, bn_ctx) == 0)
            {
                std::cerr << "BN_gcd() failed" << std::endl;
                exit(-1);
            }

            //no common primes found
            if(BN_is_one(r) == 1)
            {
                continue;
            }

            //keys are identical
            if(BN_cmp(r, i->second.n) == 0 or BN_cmp(r, j->second.n) == 0)
            {
                continue;
            }

            //we have common primes at this point
            RSA_Private_Key key1, key2;

            compute_private_key_with_known_prime(&i->second, &key1, r, bn_ctx);
            compute_private_key_with_known_prime(&j->second, &key2, r, bn_ctx);

            private_keys[0][i->first] = key1;
            private_keys[0][j->first] = key2;
        }
    }

    BN_CTX_free(bn_ctx);
    BN_free(r);
}

void WritePrivateKey(const char *path, RSA_Private_Key *key)
{
    RSA *rsa_key = RSA_new();
    if (rsa_key == NULL)
    {
        std::cerr << "RSA_new() failed" << std::endl;
        exit(-1);
    }

    if(!RSA_set0_key(rsa_key, key->n, key->e, key->d))
    {
        std::cerr << "RSA_set0_key() failed" << std::endl;
        exit(-1);
    }

    if(!RSA_set0_factors(rsa_key, key->p, key->q))
    {
        std::cerr << "RSA_set0_factors() failed" << std::endl;
        exit(-1);
    }

    RSA_set0_crt_params(rsa_key, key->dmp1, key->dmq1, key->iqmp);

    EVP_PKEY *pkey = EVP_PKEY_new();
    if(!pkey)
    {
        std::cerr << "EVP_PKEY_new() failed" << std::endl;
        exit(-1);
    }

    if(!EVP_PKEY_set1_RSA(pkey, rsa_key))
    {
        std::cerr << "EVP_PKEY_set1_RSA() failed" << std::endl;
        exit(-1);
    }

    RSA_free(rsa_key);

    FILE *fp = fopen(path, "wb");
    if(!fp)
    {
        std::cerr << "fopen(..., wb) failed" << std::endl;
        exit(-1);
    }

    if(!PEM_write_PrivateKey(fp, pkey, NULL, NULL, 0, NULL, NULL))
    {
        std::cerr << "PEM_write_PrivateKey() failed" << std::endl;
        exit(-1);
    }

    fclose(fp);
    EVP_PKEY_free(pkey);

    /*
        Use this command to read the private key data:
        openssl rsa -in privkey.pem -check -text -noout
    */
}

void GenerateRsaPubKeyWithPrimes(const char *path, const std::string &p_dec, const std::string &q_dec, const std::string &e_dec)
{
    RSA *rsa_key = RSA_new();
    if (rsa_key == NULL)
    {
        std::cerr << "RSA_new() failed" << std::endl;
        exit(-1);
    }

    BN_CTX *bn_ctx = BN_CTX_new();
    if (bn_ctx == NULL)
    {
        std::cerr << "BN_CTX_new() failed" << std::endl;
        exit(-1);
    }

    BIGNUM *p = NULL;
    BIGNUM *q = NULL;
    BIGNUM *e = NULL;

    if (!BN_dec2bn(&p, p_dec.c_str()) or !BN_dec2bn(&q, q_dec.c_str()) or !BN_dec2bn(&e, e_dec.c_str()))
    {
        std::cerr << "BN_dec2bn() failed" << std::endl;
        exit(-1);
    }

    BIGNUM *n = BN_new();
    BIGNUM *p_1 = BN_new();
    BIGNUM *q_1 = BN_new();
    BIGNUM *phi = BN_new();
    BIGNUM *d = BN_new();

    if (!n or !p_1 or !q_1 or !phi or !d)
    {
        std::cerr << "BN_new() failed" << std::endl;
        exit(-1);
    }

    if (!BN_sub(p_1, p, BN_value_one()) or !BN_sub(q_1, q, BN_value_one()))
    {
        std::cerr << "BN_sub() failed" << std::endl;
        exit(-1);
    }

    if (!BN_mul(n, p, q, bn_ctx) or !BN_mul(phi, p_1, q_1, bn_ctx))
    {
        std::cerr << "BN_mul() failed" << std::endl;
        exit(-1);
    }

    if (!BN_mod_inverse(d, e, phi, bn_ctx))
    {
        std::cerr << "BN_mod_inverse() failed" << std::endl;
        exit(-1);
    }

    if (!RSA_set0_key(rsa_key, n, e, d))
    {
        std::cerr << "RSA_set0_key() failed" << std::endl;
        exit(-1);
    }

    EVP_PKEY *pkey = EVP_PKEY_new();
    if(!pkey)
    {
        std::cerr << "EVP_PKEY_new() failed" << std::endl;
        exit(-1);
    }

    if(!EVP_PKEY_set1_RSA(pkey, rsa_key))
    {
        std::cerr << "EVP_PKEY_set1_RSA() failed" << std::endl;
        exit(-1);
    }

    RSA_free(rsa_key);

    FILE *fp = fopen(path, "wb");
    if (!fp)
    {
        std::cerr << "fopen(..., wb) failed" << std::endl;
        exit(-1);
    }

    if (!PEM_write_PUBKEY(fp, pkey))
    {
        std::cerr << "PEM_write_PUBKEY() failed" << std::endl;
        exit(-1);
    }

    fclose(fp);
    EVP_PKEY_free(pkey);

    BN_free(p);
    BN_free(q);
    BN_free(p_1);
    BN_free(q_1);
    BN_free(phi);

    BN_CTX_free(bn_ctx);
}

int main()
{
    std::map<std::string, RSA_Public_Key> RSA_Keys;
    std::map<std::string, RSA_Private_Key> Decrypted_Keys;

    for (const auto &dirEntry : std::filesystem::recursive_directory_iterator("public_keys"))
    {
        ReadPublicKey(dirEntry.path().c_str(), dirEntry.path().stem().c_str(), &RSA_Keys);
    }

/*
    // print the public keys
    for(auto i = RSA_Keys.begin(); i != RSA_Keys.end(); i++)
    {
        std::cout << i->first << std::endl;
        std::cout << "n = "; print_bignum(i->second.n); std::cout << std::endl;
        std::cout << std::endl;
    }
*/

    search_for_prime_collision(&RSA_Keys, &Decrypted_Keys);

    //save the decrypted keys
    for(auto i = Decrypted_Keys.begin(); i != Decrypted_Keys.end(); i++)
    {
        std::cout << "Solved the private key of " << i->first << std::endl;

        std::string path = "decrypted_keys/";
        path.append(i->first);
        path.append(".pem");
        
        WritePrivateKey(path.c_str(), &i->second);
    }

    //free memory
    for(auto i = RSA_Keys.begin(); i != RSA_Keys.end(); i++)
    {
        BN_free(i->second.n);
        BN_free(i->second.e);
    }

/*
    //generate demo keys
    std::string p1 = "3932268170385450581918192092953069664117960105374930412288642709179132954385034160703605074420719072950311104758912637524723664477";
    std::string p2 = "3972067117829003428292709212682609236784226429455511983513253913963749004412120495209871742449343023117842963379892246588548942323";
    std::string p3 = "7105159084429887828225799862140080805998321413258744029902851959449826619605670250900709444709327099713861621286724136473028034083";
    std::string e = "65537";

    GenerateRsaPubKeyWithPrimes("public_keys/vulnerable1", p1, p2, e);
    GenerateRsaPubKeyWithPrimes("public_keys/vulnerable2", p3, p2, e);
*/

    return 0;
}
